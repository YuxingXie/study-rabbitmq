## 第四章 发布确认

### 4.1 原理

生产者发布完消息，rabbitMQ保存消息至磁盘，然后rabbitMQ通知生产者保存结果。前提是消息和队列都要设置为持久化。

### 4.2 发布确认策略


#### 4.2.1 单个确认发布

单个发布确认是指消息每一个都要等amq确认才发送下一个，代码是同步执行的，效率肯定低啦。


关键代码：

```text
    channel.confirmSelect();

    boolean confirmed=channel.waitForConfirms();
```

完整代码：
[PublisherC4_1.java](https://github.com/YuxingXie/study-rabbitmq/blob/main/src/main/java/com/lingyun/study/rabbitmq/c4/PublisherC4_1.java)

1000条耗时722毫秒，实际上每条不足一毫秒，其实也挺快的，但是如果超级多，这种方法还是不够快。

#### 4.2.2 批量确认发布

和单个发布确认不同的是channel.waitForConfirms()方法是在多执行channel.basicPublish(..)后执行，是一种编程技巧，并没有新的知识点，
amq框架并不提供批量发布的编程API。

还是写一下代码吧：
[PublisherC4_2.java](https://github.com/YuxingXie/study-rabbitmq/blob/main/src/main/java/com/lingyun/study/rabbitmq/c4/PublisherC4_2.java)

有意思的是Channel除了waitForConfirms()方法外还有几个重载或类似方法,我把doc翻译了一下：
```java
public interface Channel extends ShutdownNotifier, AutoCloseable {
    //other codes
    /**
     * 等待直到自上次调用以来发布的所有消息都被代理ack或nack处理完毕。
     * 注意，当在非confirm通道上调用时，waitForConfirms会抛出一个IllegalStateException异常。
     * @return 是否所有消息都被ack了(没有消息被ack了)
     * @throws java.lang.IllegalStateException
     */
    boolean waitForConfirms() throws InterruptedException;

    /**
     * 等待直到自上次调用以来发布的所有消息都已完成
     * 要么被broker通知过(ack'd)，要么被broker否定通知过(nack'd);或者直到超时结束。
     * 如果超时过期，则抛出TimeoutException。
     * 当在一个非confirm通道上调用，waitForConfirms抛出一个IllegalStateException。
     * @return whether all the messages were ack'd (and none were nack'd)
     * @throws java.lang.IllegalStateException
     */
    boolean waitForConfirms(long timeout) throws InterruptedException, TimeoutException;

    /** 等待直到自上次调用以来发布的所有消息都被代理ack或nack处理完毕。
     *  如果有任何消息被nack, waitForConfirmsOrDie将抛出IOException。
     *  When called on a non-Confirm channel, it will
     * throw an IllegalStateException.
     * @throws java.lang.IllegalStateException
     */
     void waitForConfirmsOrDie() throws IOException, InterruptedException;

    /** Wait until all messages published since the last call have
     * been either ack'd or nack'd by the broker; or until timeout elapses.
     * If the timeout expires a TimeoutException is thrown.  If any of the
     * messages were nack'd, waitForConfirmsOrDie will throw an
     * IOException.  When called on a non-Confirm channel, it will
     * throw an IllegalStateException.
     * @throws java.lang.IllegalStateException
     */
    void waitForConfirmsOrDie(long timeout) throws IOException, InterruptedException, TimeoutException;
}

```
```text
boolean waitForConfirms() throws InterruptedException;
boolean waitForConfirms(long timeout) throws InterruptedException, TimeoutException;
void waitForConfirmsOrDie() throws IOException, InterruptedException;
void waitForConfirmsOrDie(long timeout) throws IOException, InterruptedException, TimeoutException;
```
翻译一下很好理解了吧。

非confirm通道：应该是没有调用channel.confirmSelect()的通道。

#### 4.2.3 异步确认发布

    根据rabbitMQ API的语言习惯，从这里开始，rabbitMQ=amq，发布确认=ack（acknowledge）。

异步确认发布是通过另一个线程来处理amq的ack。

异步ack是通过监听器实现的，有2种方式：
```java
public interface Channel extends ShutdownNotifier, AutoCloseable {
   /**
     * Add a {@link ConfirmListener}.
     * @param listener the listener to add
     */
    void addConfirmListener(ConfirmListener listener);

    /**
     * Add a lambda-based {@link ConfirmListener}.
     * @see ConfirmListener
     * @see ConfirmCallback
     * @param ackCallback callback on ack
     * @param nackCallback call on nack (negative ack)
     * @return the listener that wraps the callbacks
     */
    ConfirmListener addConfirmListener(ConfirmCallback ackCallback, ConfirmCallback nackCallback);
}
 
```

ConfirmListener与ConfirmCallback传入方法的参数都一样。第二种方式可能会简洁一些，因为回调接口的参数ackCallback或nackCallback可以传null。

另外：
```java
@FunctionalInterface
public interface ConfirmCallback {

    void handle(long deliveryTag, boolean multiple) throws IOException;

}
```
long deliveryTag字面上看是个long型的快递标记，不知道是对应一个消息，还是对应一次ack或nack动作，可能和channel.getNextPublishSeqNo()方法有点关系。

在回调函数中，似乎并不能获得消息本身。



