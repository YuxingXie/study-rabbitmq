## 第三章 Work Queues模式

### 3.1 轮询接收消息

源码：

[ConsumerC3_1](https://github.com/YuxingXie/study-rabbitmq/raw/main/src/main/java/com/lingyun/study/rabbitmq/c3/ConsumerC3_1.java)

[PublisherC3_1](https://github.com/YuxingXie/study-rabbitmq/raw/main/src/main/java/com/lingyun/study/rabbitmq/c3/PublisherC3_1.java)

PublisherC3_1无限发消息，启动2个线程接收消息。

如何在IDEA启动两个ConsumerC3_1：先运行一个ConsumerC3_1.main,在右上角出现的ConsumerC3_1下拉框
点击Edit Configurations...勾选Allow parallel run，即可两个ConsumerC3_1同时run。

打印结果：
第一个线程：
```text
deliverCallback message:message 105
deliverCallback message:message 107
deliverCallback message:message 109
deliverCallback message:message 111
deliverCallback message:message 113
deliverCallback message:message 115
deliverCallback message:message 117
deliverCallback message:message 119
```
第二个线程
```text
deliverCallback message:message 106
deliverCallback message:message 108
deliverCallback message:message 110
deliverCallback message:message 112
deliverCallback message:message 114
deliverCallback message:message 116
deliverCallback message:message 118
deliverCallback message:message 120
```
的确是轮询接收。

所以一个生产者对应多个消费者的时候，一条消息只有其中一个消费者能获取。

或许我们应该换一种说法，每个生产者和消费者都对应一个Channel，一个Channel publish的时候，只有一个Channel能consume。

### 3.2 消息应答

消费者接收消息后告诉rabbitMQ消息已消费完成，避免消息丢失。

#### 3.2.1 自动应答

Channel中的basicConsume方法的第二个参数autoAck设置是否自动应答：
```text
方法签名：
String basicConsume(String queue, boolean autoAck, DeliverCallback deliverCallback, CancelCallback cancelCallback) throws IOException;
```
#### 3.2.2 手动应答

        channel.basicAck(..);
        channel.basicNack(..);
        channel.basicReject(..);
        
这几个方法都表示手动应答，第一个肯定应答，后二个否定应答。

[手动应答代码](https://github.com/YuxingXie/study-rabbitmq/raw/main/src/main/java/com/lingyun/study/rabbitmq/c3/ConsumerC3_2.java)


#### 3.2.2 消息重新入队
    