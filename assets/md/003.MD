## 第三章 Work Queues模式

### 3.1 轮询接收消息

源码：

[ConsumerC3_1.java](https://github.com/YuxingXie/study-rabbitmq/blob/main/src/main/java/com/lingyun/study/rabbitmq/c3/ConsumerC3_1.java)

[PublisherC3_1.java](https://github.com/YuxingXie/study-rabbitmq/blob/main/src/main/java/com/lingyun/study/rabbitmq/c3/PublisherC3_1.java)

PublisherC3_1无限发消息，启动2个线程接收消息。

如何在IDEA启动两个ConsumerC3_1：先运行一个ConsumerC3_1.main,在右上角出现的ConsumerC3_1下拉框
点击Edit Configurations...勾选Allow parallel run，即可两个ConsumerC3_1同时run。

打印结果：
第一个线程：
```text
deliverCallback message:message 105
deliverCallback message:message 107
deliverCallback message:message 109
deliverCallback message:message 111
deliverCallback message:message 113
deliverCallback message:message 115
deliverCallback message:message 117
deliverCallback message:message 119
```
第二个线程
```text
deliverCallback message:message 106
deliverCallback message:message 108
deliverCallback message:message 110
deliverCallback message:message 112
deliverCallback message:message 114
deliverCallback message:message 116
deliverCallback message:message 118
deliverCallback message:message 120
```
的确是轮询接收。

所以一个生产者对应多个消费者的时候，一条消息只有其中一个消费者能获取。

或许我们应该换一种说法，每个生产者和消费者都对应一个Channel，一个Channel publish的时候，只有一个Channel能consume。

### 3.2 消息应答

消费者接收消息后告诉rabbitMQ消息已消费完成，避免消息丢失。

#### 3.2.1 自动应答

Channel中的basicConsume方法的第二个参数autoAck设置是否自动应答：
```text


方法签名：(autoAck true if the server should consider messages acknowledged once delivered; false if the server should expect)

String basicConsume(String queue, boolean autoAck, DeliverCallback deliverCallback, CancelCallback cancelCallback) throws IOException;
```
#### 3.2.2 手动应答

        channel.basicAck(..);
        channel.basicNack(..);
        channel.basicReject(..);
        
这几个方法都表示手动应答，第一个肯定应答，后二个否定应答。

手动应答代码:
[ConsumerC3_2.java](https://github.com/YuxingXie/study-rabbitmq/blob/main/src/main/java/com/lingyun/study/rabbitmq/c3/ConsumerC3_2.java)

顺便看看com.rabbitmq.client.Delivery，com.rabbitmq.client.Envelope这几个类的源码。

#### 3.2.2 消息重新入队

在手动应答方式下，消费者如果出现异常、连接中断等问题，rabbitMQ会将消息重新入列，消息不会丢失。

### 3.3 rabbitMQ持久化

#### 3.3.1  队列持久化


在生产者声明队列时可设置队列是否持久化：
```text
第二个参数表示是否持久化队列：
durable: true if we are declaring a durable queue (the queue will survive a server restart)

channel.queueDeclare(QUEUE_NAME,false,false,false,null);
```

即便rabbitMQ宕机重启，队列中也不会消失。

注意：被持久化的目标是队列，但不包括它包含的消息。在UI界面Queues tab上可以看到被持久化的队列打上了D标记。

如果已存在不持久化的同名队列，改为持久化以后需要先删除该队列。
```text
        channel.queueDelete(QUEUE_NAME);
```

#### 3.3.2  消息持久化

前面讲的队列持久化并不能持久化队列中的消息。要持久化消息，需要发布者设置这个消息需要被持久化

```text
    //持久化消息
    channel.basicPublish("",ConsumerC3_1.QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());

```
实际上这样也不能完全确保消息绝对保存成功，因为还有缓存再写入的过程，在这个过程中消息仍可能丢失。要确保完全保存成功，
见下章 [发布确认](https://github.com/YuxingXie/study-rabbitmq/blob/main/assets/md/004.MD) 。